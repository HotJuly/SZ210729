# Vue生命周期
1. Vue一共具有多少个生命周期?常用多少个?
   1. Vue一共具有11个生命周期,常用8个
2. Vue生命周期阶段划分
   1. Vue前端渲染
      1. 初始化阶段
         1. beforeCreate
            1. **beforeCreate之前,Vue正在初始化事件和生命周期**
         2. created
            1. 做的事情
               1. 发送请求
            2. 区别:
               1. 前情提要:js引擎是单线程引擎,解析js代码是**单线程同步解析**
               2. 优点:更早发送请求,相对来说可以更早得到返回的响应数据,减少页面展示空白内容时间(更快展示有用数据)
               3. 缺点:在此阶段做事情,会阻塞后续代码执行,假设在此处阻塞10秒钟,页面也会延迟10秒进行解析展示
               4. 注意:此处不要做太多的逻辑密集类型操作
            3. **beforeCreate之后created之前,Vue正在进行data,methods,computed等配置项的注入(数据代理)和数据劫持(响应式)**
         3. beforeMount
            1. **created之后beforeMount之前,**
               1. **检查是否具有el配置属性**
                  1. **如果没有该属性,是否具有$mount方法调用**
                  2. **如果都没有,那么组件将不会进行挂载(页面不会显示)**
               2. **检查是否具有render方法**
                  1. **如果具有render方法,直接结束**
                  2. **如果不具有render方法,会检查是否具有template属性**
                     1. **如果有template属性,会将template的结果编译成render方法**
                     2. **如果没有template属性,会将el元素中的内容作为模版进行解析,变成render方法**
               3. **总结:执行beforeMount的时候,一定具有render方法,但是不会调用render方法,所以不会生成虚拟DOM,render方法用于生成对应的虚拟DOM**
               4. 实例对象身上的$vnode属性用于存储父组件的虚拟DOM,_vnode存储的是当前组件内部节点的虚拟DOM
         4. mounted
            1. 做的事情
               1. 发送请求
               2. 开启定时器
               3. 绑定自定义事件
               4. 操作真实DOM
                  1. new Swiper
                  2. 使用$refs进行页面内容控制
            2. 优点:
               1. 由于页面已经挂载结束,所以在此生命周期做的事情都不会阻塞页面的渲染
            3. 缺点:
               1. 由于更晚发送请求,相对来说得到数据的时间就会更晚,页面展示空白内容更久
            4. **beforeMount之后mounted之前,Vue会调用render方法生成虚拟DOM,并通过虚拟DOM生成对应的真实DOM对象,最终替换掉index.html中的el元素**
      2. 更新阶段
         1. beforeUpdate
         2. updated
            1. 由于数据发生变化导致响应式触发,页面重新渲染,此时需要二次操作真实DOM,就会在该生命周期操作
      3. 卸载阶段
         1. beforeDestroy
            1. 关闭当前组件开启的定时器
            2. 解绑事件
               1. 通过@符号绑定的原生DOM事件
                  1. 该类型**不需要**开发者手动解绑,因为@符是Vue的语法,他会记录绑定的事件,会自动解绑
               2. 通过原生DOM添加onclick或者addEventListener绑定的原生DOM事件
                  1. 该类型**需要**开发者手动解绑,因为该类型语法没有经过Vue的语法解析,Vue不知道绑定了该事件
                  2. 例如:为了实现某块区域自动吸顶功能,需要监视系统滚动条,就需要绑定原生DOM事件
               3. 通过@符或者$on绑定的组件自定义事件
                  1. 该类型**不需要**开发者手动解绑,因为经过了Vue语法的解析,Vue会记录当前组件绑定的自定义事件($listeners)
               4. 通过全局事件总线对象绑定的自定义事件
                  1. 该类型**需要**开发者手动解绑,因为虽然是当前组件绑定的自定义事件,但是该事件绑定给了$bus,当前组件卸载的时候,全局事件总线不会被销毁,导致身上依旧存有之前绑定的自定义事件
         2. destroyed
      4. keep-alive专用
         1. 被keep-alive包裹的组件,组件实例对象会被keep-alive组件进行缓存,会导致内部组件无法销毁和重新挂载(失去了初始化阶段和卸载阶段)
         2. activated(激活)
         3. deactivated(失活)
      5. Vue捕获报错
         1. errorCaptured
            1. 该生命周期,用于捕获后代组件出现的错误
         2. Vue.config.errorHandler
            1. 该配置,可以用于捕获Vue项目中出现的错误
   2. Vue后端渲染专用
      1. ServerPrefetch
         1. 它相当于是Vue前端渲染中的mounted