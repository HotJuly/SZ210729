# VueRouter原理分析

1. 对VueRouter的了解
   1. 他是Vue的扩展插件库(Vue.use)
   2. 它适用于实现SPA应用的插件(用于实现单页面应用效果)
   3. 问题:什么是单页面应用?
      1. 页面->html文件
      2. 如果一个项目只有一个html文件,那么该项目可以称之为单页面应用
      3. 单页面应用只有一个html文件,但是可以看到非常多内容的原因,是因为使用了原生DOM的CRUD方法对当前页面内容进行修改,实现展示内容的切换
   4. 总结:其实VueRouter不是一个必须使用的库,Vue自己完全有能力实现单页面应用,但是语法比较复杂,所以才推荐使用VueRouter实现多组件切换效果
2. VueRouter给我们提供了什么?
   1. 构造函数
      1. 调用该构造函数可以创建得到路由器实例对象
   2. 全局组件
      1. router-view
         1. 它相当于是VueRouter组件的占位符
         2. 当地址栏中的地址匹配某个path时,页面会自动显示对应的component,最终会替换掉router-view组件以此显示
      2. router-link
         1. 他其实是声明式导航的一员
            1. **声明式导航:通过页面上的某个标签来引导用户进行路由跳转**
         2. 他默认会生成a标签
            1. router-link生成的a标签与普通的a标签的区别
               1. 普通的a标签点击之后会发生页面跳转效果,会重新请求一个全新的网页
               2. 但是router-link的a标签其实是伪跳转,他并没有真正的进行跳转,他只是修改了当前地址栏中的地址,**他禁用了原生a标签的默认行为**
         3. 必传属性
            1. to属性
               1. 该属性用于声明用户点击当前标签时,需要跳转的指定路由地址信息
   3. 全局对象
      1. $router
         1. 该对象是路由器实例对象
         2. 该对象用于向开发者提供操作当前路由的API
            1. push(地址)
               1. **编程式导航:通过js代码控制用户进行路由跳转**
            2. replace(地址)
      2. $route
         1. 该对象是路由实例对象
         2. 该对象用于向开发者提供与当前所处路由相关的信息
            1. params
               1. 语法:/home/数据
            2. query
               1. 语法:/home?key=value
            3. meta
3. 我们需要给VueRouter提供什么?
   1. 配置对象
      1. mode属性
         1. 属性值类型:string
         2. **hash**
            1. **告知VueRouter当前路由运行模式为URL hash模式**
            2. **hash模式地址栏会以/#/开头**
            3. **优点:**
               1. **兼容性好,几乎所有浏览器都支持该模式**
               2. **前端的hash路由不会被当做后端路由发送给服务器,所以上线不需要做特殊的配置**
            4. **缺点:**
               1. **长得太丑,地址栏中会携带#号**
               2. **会导致锚点功能失效**
            5. **原理:**
               1. **如何控制地址栏的地址变化**
                  1. **使用window.location.hash="需要跳转的路由地址",可以控制浏览器历史记录栈变化,而且不会导致当前浏览器重新请求资源**
               2. **VueRouter是如何监视地址变化,从而显示对应组件的?**
                  1. **可以给浏览器绑定事件监听,监听window的hashchange事件,当浏览器的hash值发生变化,就会触发该事件的回调函数,并且通过事件对象event提供与本次跳转相关的数据**
                  2. **其实显示对应组件就是用到了响应式原理实现的**
         3. **history**
            1. **告知VueRouter当前路由运行模式为history模式**
            2. **history模式地址栏会以/开头**
            3. **优点:**
               1. **长得好看,颜值就是正义**
               2. **锚点功能可以正常使用**
            4. **缺点:**
               1. **兼容性较差,该模式用到html5的新特性history对象**
               2. **面试题:请问使用history模式是否有遇到过什么问题?**
                  1. **如果用户处于某个前端路由地址,此时刷新浏览器,浏览器会报404的错误**
                  2. **该问题出现原因(浏览器误将前端路由,发送给服务器作为后端路由解析):**
                     1. **由于用户刷新浏览器,浏览器会根据当前地址栏中的内容发送请求**
                     2. **此时浏览器会将本属于前端路由的地址发送到服务器**
                     3. **服务器接收到浏览器的路由请求("/about"),服务器开始查找对应的路由接口**
                     4. **服务器查找结束,发现并没有配置该路由接口,最终返回响应404**
                  3. **该问题的解决方法(要求服务器将自己没有的接口统一返回index.html文件):**
                     1. **用户刷新浏览器,浏览器会根据当前地址栏中的内容发送请求**
                     2. **此时浏览器会将本属于前端路由的地址发送到服务器**
                     3. **服务器接收到浏览器的路由请求("/about"),服务器开始查找对应的路由接口**
                     4. **如果服务器没有找到对应的后端接口,此时服务器自动返回当前项目的index.html文件**
                     5. **浏览器接收到index.html文件,html文件自动请求index.js文件**
                     6. **index.js文件中的VueRouter代码自动执行,自动将当前浏览器地址栏中的地址作为前端路由解析**
                     7. **最终浏览器自动展示对应的路由组件**
            5. 原理:
               1. ​
      2. routes属性
         1. 属性值类型:routeObj[]
         2. 用于存放当前项目所有的路由对象信息
            1. 路由对象必备参数
               1. path
                  1. 声明当前路由的路由地址
               2. component
                  1. 声明当前路由的路由组件(当地址栏中的地址匹配某个path时,页面会自动显示对应的component)


